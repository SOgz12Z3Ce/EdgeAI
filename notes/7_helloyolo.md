# YOLO Hello World

人生中第一次跑 YOLO，可喜可贺。体会是机器学习真是个非常费资源的玩意，动不动就把 CPU 和内存拉满了，跑得还那么慢。

## 问题

也不知惹了什么邪，就这么几行代码居然也能报错了……

经典的有：

- Out of Memory：爆内存，加载模型参数的时候 16G 的内存也会拉满，再开个浏览器、IDE 更是雪上加霜（运行时反倒不需要那么多内存）。
- CUDA Out of Memory：爆显存，显存不够，GPU 扛不住。（时有时没有，玄学）

此外还遇到一个特别奇怪的：

```
Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initialized.
```

搜了一圈，在[一篇文章](https://zhuanlan.zhihu.com/p/371649016)里看到是环境里的两个同名 dll 有冲突：

- ~/miniconda3/envs/（环境名）/Lib/site-packages/torch/libiomp5md.dll
- ~/miniconda3/envs/（环境名）/Library/bin/libiomp5md.dll

报错信息既然是初始化时文件已存在，那就删了试试呗。删了第一个后爆了一堆错，只能放回去。删掉第二个后就可以跑了。

## 结果

在 `./runs/detect/train` 下可以看到一大堆文件：

- `weights`：最重要的结果，里面是训练出来的模型。
  - `best.pt`：表现最好的模型。
  - `last.pt`：最后一次训练的模型。
- `args.yaml`：一大堆配置信息，任务类型、训练轮数、种子甚至保存文件的目录……有助于复现训练结果。
- 四种曲线：
  - `BoxP_curve.png`：精确率（Precision）曲线，YOLO 输出的框带有一个“置信度”表示此框处有多大可能是一个目标，这条曲线的横轴表示置信度低于多少时抛弃框，纵轴表示此时的精确率。
  - `BoxR_curve.png`：召回率（Recall）曲线，同上，但纵轴表示召回率。
  - `BoxPR_curve.png`：召回率—精确率曲线，横轴表示召回率，纵轴表示精确率。仔细想想，这就是一个以置信度为参数的参数方程。在图例后面多了一个数字，表示曲线下面积，也称“平均精度”。
    - 特别地，里面有一个“all classes ... mAP@...”，这条曲线表示“平均平均精度”，也就是每一个类别的平均精度的平均。@ 后面的数字表示在多少 IoU 下计算，IoU 是指预测框与实际框重叠多少才算预测对。
  - `BoxF1_curve.png`：F1 曲线。F1 是精确率和召回率的调和平均，它在精确率和召回率都高时才高。这个指标惩罚精确率和召回率之一很高但另一个不高的情况。我们自然关心曲线的最大值。
- 混淆矩阵：
  - `confusion_matrix.png`：展示模型把什么认成了什么。横轴是正确答案，纵轴是模型的预测。每一个小格子就表示模型把横轴上的东西认成了纵轴上的东西，颜色越深越多。对角线上的就是认对了。
  - `confusion_matrix_normalized.png`：一样，不过作了归一化，其实就是把数量换成了每一列上的占比。也许更方便看一点。
- `labels.jpg`，快速查看数据集分布的示意图，可以用来发现数据集问题
  - 左上：各类别数量
  - 右上：边界框形状
  - 左下：边界框坐标（归一化过）
  - 右下：边界框长宽（归一化过）
- `results.csv` 和 `results.png`：描述了训练过程中各种指标的变化情况。两个文件是一回事，一个是数据一个是图像。
  - box_loss/cls_loss/dfl_loss：三种损失值，分别表示框位置差距、分类差距和“Distribution Focal Loss”。前两个还好理解，第三个是相对新的技术，模型可以不直接预测框的位置，而是预测框在各个块里面存在的概率分布，并以此算出框的实际位置，Distribution Focal Loss 就是惩罚这个概率分布的。
    - train/val 的前缀表示在训练集和验证集上的表现（在验证集上居然越训越高……快 100 才变低）
  - metrics/：各种指标，后面的 `(B)` 表示 `best.pt`。
    - precision：精确度
    - recall：召回率
    - mAP50：平均平均精度，IoU = 50%
    - mAP50-95：不同 IoU 下的平均平均精度之平均（平均平均平均精度……）。不是连续的，步长 5%
- `train_batch[...].jpg`：训练过程中的结果示例，只有几个。
  - 值得注意的是，这些图像是训练集图像裁剪、循环、拼接、放大缩小、镜像翻转、调整色调……等等操作后的结果，这是为了提高模型的泛化能力，叫做数据增强。
- `val_batch0_labels.jpg`：验证集的标签。
- `val_batch0_pred.jpg`：模型在验证集上的预测效果。

## 历史

目标检测算法在早期显得很笨拙，靠手写特征，遍历图像寻找候选区域，然后用分类器判定是否有目标。这种“人工”智能效果并不好。

随着卷积神经网络的成功，人们开始使用 CNN 做目标检测。核心思路还是寻找候选区域，然后在候选区域分类和边界框回归。

YOLO 的出现打破了这个思路，要在一次计算中直接检测目标位置和类别，大大提升了速度。
